---
output:
   md_document:
     variant: markdown_github
---




```{r eval=FALSE}
devtools::install_github(c("hadley/purrr", "ropensci/EML"))
```

```{r}
library("EML")
library("purrr")
library("dplyr")
```

```{r}
obj <- eml_read("http://harvardforest.fas.harvard.edu/data/eml/hf001.xml")
```


```{r}
stuff <- obj@dataset@dataTable[[4]]@attributeList@attribute

stuff[[1]]
```


R has summarized the output using the [YAML](https://en.wikipedia.org/wiki/YAML) format, which is a bit more human readable than the XML format that EML language uses.  YAML uses a `key: value` structure, where the `key` corresponds to the name of a tag/element (or occassionally an XML attribute instead of an XML tag, but attributes are used rarely in EML, mostly just for ids) in the EML language, followed by its value.  Some of these don't appear to have a value, like `attribute:`, but look closely and you'll see the next two keys are indented further.  This means that an `attribute` tag consists of two child tags, `attributeName` and `attributeDefinition`.  We can see this in the subsetting, as 

```{r}
slotNames(stuff[1])

stuff[[1]]@attributeName
stuff[[1]]@attributeDefinition
```

So, we want to see all the `attributeName`s and `attributeDefinition`s for Table 4.  We could just print `stuff`, but that is much to verbose since it has all that stuff about `measurementScale` etc that we aren't interested in right now.  So, we use a little R scripting to extract just the information we want:

```{r}
purrr::map_df(stuff, function(x) data.frame(column.name = x@attributeName, definition = x@attributeDefinition))

# Or identically with dplyr alone:
#dplyr::bind_rows(lapply(stuff, function(x) data.frame(column.name = x@attributeName, definition = x@attributeDefinition)))

do.call(rbind, lapply(stuff, function(x) data.frame(column.name = x@attributeName, definition = x@attributeDefinition)))

```

This creates a `data.frame` with two columns: the name of every column in Table 4, and a description of what each of those 29 columns contains.  Similarly we can create a `data.frame` that summarizes all of the tables in the dataset:

```{r}
purrr::map_df(obj@dataset@dataTable, function(dt) 
  data.frame(table.id = dt@id,
             table.description = dt@entityDescription))
```

and we can also combine this information directly with the `data.frame` describing the attributes of each table:

```{r}
df <-
purrr::map_df(obj@dataset@dataTable, function(dt) 
  data.frame(table.id = dt@id,
             table.description = dt@entityDescription, 
             purrr::map_df(dt@attributeList@attribute, function(x) 
               data.frame(column.name = x@attributeName, column.definition = x@attributeDefinition))))
df
```


This permits us to use typical R manipulations to quickly search this metadata, for instance, to identify which tables contain information about, say, the extreme maximum air temperature over monthly intervals:

```{r}
df %>% filter(grepl("extreme maximum air temperature", column.definition), grepl("monthly", table.description))

```